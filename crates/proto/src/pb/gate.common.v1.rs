// This file is @generated by prost-build.
/// Gate node identifier (32 bytes)
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateId {
    /// Must be exactly 32 bytes
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
/// Network socket address
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SocketAddr {
    #[prost(oneof = "socket_addr::Addr", tags = "1, 2")]
    pub addr: ::core::option::Option<socket_addr::Addr>,
}
/// Nested message and enum types in `SocketAddr`.
pub mod socket_addr {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Addr {
        /// "ip:port" format
        #[prost(string, tag = "1")]
        Ipv4(::prost::alloc::string::String),
        /// "\[ip\]:port" format
        #[prost(string, tag = "2")]
        Ipv6(::prost::alloc::string::String),
    }
}
/// Gate node address containing ID and direct addresses
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateAddr {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<GateId>,
    #[prost(message, repeated, tag = "2")]
    pub direct_addresses: ::prost::alloc::vec::Vec<SocketAddr>,
}
/// JSON value for dynamic content
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JsonValue {
    /// JSON-encoded string (simpler than google.protobuf.Struct)
    #[prost(string, tag = "1")]
    pub json: ::prost::alloc::string::String,
}
/// Protocol version information
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProtocolVersion {
    #[prost(uint32, tag = "1")]
    pub major: u32,
    #[prost(uint32, tag = "2")]
    pub minor: u32,
    #[prost(uint32, tag = "3")]
    pub patch: u32,
}
/// Comprehensive error structure
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(enumeration = "error::ErrorCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Additional context for debugging
    #[prost(map = "string, string", tag = "3")]
    pub details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Error`.
pub mod error {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ErrorCode {
        Ok = 0,
        RequestFailed = 1,
        PermissionDenied = 2,
        NotFound = 3,
        InvalidArgument = 4,
        InternalError = 5,
        ServiceUnavailable = 6,
        Timeout = 7,
        RateLimited = 8,
        TaskFailed = 9,
        TaskCancelled = 10,
        DnsChallengeFailed = 11,
    }
    impl ErrorCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Ok => "OK",
                Self::RequestFailed => "REQUEST_FAILED",
                Self::PermissionDenied => "PERMISSION_DENIED",
                Self::NotFound => "NOT_FOUND",
                Self::InvalidArgument => "INVALID_ARGUMENT",
                Self::InternalError => "INTERNAL_ERROR",
                Self::ServiceUnavailable => "SERVICE_UNAVAILABLE",
                Self::Timeout => "TIMEOUT",
                Self::RateLimited => "RATE_LIMITED",
                Self::TaskFailed => "TASK_FAILED",
                Self::TaskCancelled => "TASK_CANCELLED",
                Self::DnsChallengeFailed => "DNS_CHALLENGE_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OK" => Some(Self::Ok),
                "REQUEST_FAILED" => Some(Self::RequestFailed),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "NOT_FOUND" => Some(Self::NotFound),
                "INVALID_ARGUMENT" => Some(Self::InvalidArgument),
                "INTERNAL_ERROR" => Some(Self::InternalError),
                "SERVICE_UNAVAILABLE" => Some(Self::ServiceUnavailable),
                "TIMEOUT" => Some(Self::Timeout),
                "RATE_LIMITED" => Some(Self::RateLimited),
                "TASK_FAILED" => Some(Self::TaskFailed),
                "TASK_CANCELLED" => Some(Self::TaskCancelled),
                "DNS_CHALLENGE_FAILED" => Some(Self::DnsChallengeFailed),
                _ => None,
            }
        }
    }
}
/// Standard result wrapper for operations that can fail
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Result {
    #[prost(oneof = "result::Result", tags = "1, 2")]
    pub result: ::core::option::Option<result::Result>,
}
/// Nested message and enum types in `Result`.
pub mod result {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// Serialized success response
        #[prost(bytes, tag = "1")]
        Success(::prost::alloc::vec::Vec<u8>),
        /// Error details
        #[prost(message, tag = "2")]
        Error(super::Error),
    }
}
/// Peer capabilities for session establishment
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerCapabilities {
    /// ALPN identifiers
    #[prost(string, repeated, tag = "1")]
    pub supported_protocols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Gate software version
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Node role
    #[prost(enumeration = "NodeRole", tag = "3")]
    pub role: i32,
    /// Feature flags and metadata
    #[prost(map = "string, string", tag = "4")]
    pub features: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Session establishment request
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionRequest {
    #[prost(message, optional, tag = "1")]
    pub peer_id: ::core::option::Option<GateId>,
    #[prost(message, optional, tag = "2")]
    pub capabilities: ::core::option::Option<PeerCapabilities>,
    /// Additional session metadata
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Session establishment response
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionResponse {
    #[prost(oneof = "session_response::Result", tags = "1, 2")]
    pub result: ::core::option::Option<session_response::Result>,
}
/// Nested message and enum types in `SessionResponse`.
pub mod session_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SessionOk {
        #[prost(string, tag = "1")]
        pub session_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub server_capabilities: ::core::option::Option<super::PeerCapabilities>,
        #[prost(message, optional, tag = "3")]
        pub config: ::core::option::Option<super::SessionConfig>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Ok(SessionOk),
        #[prost(message, tag = "2")]
        Error(super::Error),
    }
}
/// Session configuration parameters
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SessionConfig {
    /// How often to send heartbeats
    #[prost(uint32, tag = "1")]
    pub heartbeat_interval_seconds: u32,
    /// Max time before session timeout
    #[prost(uint32, tag = "2")]
    pub max_idle_seconds: u32,
    /// Max concurrent requests per session
    #[prost(uint32, tag = "3")]
    pub max_concurrent_requests: u32,
    /// Default request timeout
    #[prost(uint32, tag = "4")]
    pub request_timeout_seconds: u32,
}
/// Connection context for observability and tracing
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionContext {
    /// Iroh Connection ID
    #[prost(string, tag = "1")]
    pub connection_id: ::prost::alloc::string::String,
    /// Iroh Stream ID
    #[prost(string, tag = "2")]
    pub stream_id: ::prost::alloc::string::String,
    /// Gate session ID
    #[prost(string, tag = "3")]
    pub session_id: ::prost::alloc::string::String,
    /// Remote peer ID
    #[prost(message, optional, tag = "4")]
    pub peer_id: ::core::option::Option<GateId>,
    /// ALPN protocol identifier
    #[prost(string, tag = "5")]
    pub protocol: ::prost::alloc::string::String,
    /// Connection establishment time
    #[prost(int64, tag = "6")]
    pub timestamp: i64,
    /// Additional context tags
    #[prost(map = "string, string", tag = "7")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Node role in the Gate network
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeRole {
    /// Provides inference and may support relay
    Daemon = 0,
    /// Provides relay services
    Relay = 1,
    /// Client-only node (future use)
    Client = 2,
}
impl NodeRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Daemon => "DAEMON",
            Self::Relay => "RELAY",
            Self::Client => "CLIENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DAEMON" => Some(Self::Daemon),
            "RELAY" => Some(Self::Relay),
            "CLIENT" => Some(Self::Client),
            _ => None,
        }
    }
}
